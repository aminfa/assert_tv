use crate::caller_location::pretty_location_file;
use crate::TlsEnvGuard;
use crate::{
    initialize_tv_case_from_file, DynDeserializer, DynSerializer, TestMode, TestVectorFileFormat,
};
use std::fmt::{Debug, Formatter};
use std::marker::PhantomData;
use std::panic::Location;
use std::path::PathBuf;

/// Helper trait implemented by `#[derive(TestVectorSet)]` to construct a struct
/// whose fields are `TestValue<…>` for the current source location.
///
/// Users should not implement this manually; use the derive macro instead.
pub trait TestVectorSet {
    /// Create a new set of test values specialized for the chosen `TV` implementation.
    fn start<TV: TestVector>() -> Self;
}

/// Descriptor for a single test‑vector value.
///
/// Instances are typically generated by `#[derive(TestVectorSet)]` and passed to
/// `TestVector::{expose_value, expose_mut_value, check_value}`.
pub struct TestValue<O> {
    pub name: Option<String>,
    pub description: Option<String>,
    pub test_value_field_code_location: String,
    pub serializer: Option<DynSerializer<O>>,
    pub deserializer: Option<DynDeserializer<O>>,
    pub compress: bool,
    pub offload: bool,
    pub _data_marker: PhantomData<O>,
}

impl<O> Debug for TestValue<O> {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("TestValue")
            .field("name", &self.name)
            .field("description", &self.description)
            .field(
                "test_value_field_code_location",
                &self.test_value_field_code_location,
            )
            .finish()
    }
}

impl<O> TestValue<O> {
    /// Manually construct a `TestValue`. Most users should prefer
    /// `#[derive(TestVectorSet)]`, which generates these values automatically.
    pub fn new(
        name: Option<String>,
        description: Option<String>,
        code_location: String,
        serializer: Option<DynSerializer<O>>,
        deserializer: Option<DynDeserializer<O>>,
        compress: bool,
        offload: bool,
    ) -> Self {
        Self {
            name,
            description,
            test_value_field_code_location: code_location,
            serializer,
            deserializer,
            compress,
            offload,
            _data_marker: PhantomData,
        }
    }
}

/// Core interface toggling between active (capture/validate) and no‑op behavior.
///
/// Use `TestVectorActive` in tests and `TestVectorNOP` in production.
pub trait TestVector {
    fn initialize_test_vector<T: Into<PathBuf>>(
        tv_file_path: T,
        file_format: TestVectorFileFormat,
        test_mode: TestMode,
    ) -> TlsEnvGuard {
        initialize_tv_case_from_file(tv_file_path, file_format, test_mode)
            .expect("Failed to initialize test vector")
    }

    #[inline(always)]
    fn initialize_values<T: TestVectorSet>() -> T
    where
        Self: Sized,
    {
        T::start::<Self>()
    }

    #[inline(always)]
    #[track_caller]
    /// Record a constant input and return the value loaded from the test vector.
    ///
    /// In `Init` and `Check` modes, the returned value may replace randomness to
    /// de‑randomize execution. With `TestVectorNOP`, the original `observed_value`
    /// is returned unchanged.
    fn expose_value<O>(test_vec_field: &TestValue<O>, observed_value: O) -> O {
        let caller_location = Location::caller();
        let caller_location = Some(format!(
            "{}:{}",
            pretty_location_file(caller_location.file()),
            caller_location.line()
        ));
        let value = crate::process_next_entry(
            crate::TestVectorEntryType::Const,
            test_vec_field.description.clone(),
            test_vec_field.name.clone(),
            &observed_value,
            caller_location,
            Some(test_vec_field.test_value_field_code_location.clone()),
            test_vec_field.serializer.as_ref().unwrap_or_else(|| {
                panic!("Serializer was not provided for test field: {test_vec_field:?}")
            }),
            Some(test_vec_field.deserializer.as_ref().unwrap_or_else(|| {
                panic!("Deserializer was not provided for test field: {test_vec_field:?}")
            })),
            test_vec_field.offload,
        )
        .expect("Error processing observed test vector value")
        .expect("Unexpected error processing observed test vector const: no value was loaded");
        value
    }

    #[inline(always)]
    #[track_caller]
    /// Like `expose_value`, but mutates `observed_mut_value` in place with the loaded value.
    fn expose_mut_value<O>(test_vec_field: &TestValue<O>, observed_mut_value: &mut O) {
        let caller_location = Location::caller();
        let caller_location = Some(format!(
            "{}:{}",
            pretty_location_file(caller_location.file()),
            caller_location.line()
        ));
        *observed_mut_value = crate::process_next_entry(
            crate::TestVectorEntryType::Const,
            test_vec_field.description.clone(),
            test_vec_field.name.clone(),
            observed_mut_value,
            caller_location,
            Some(test_vec_field.test_value_field_code_location.clone()),
            test_vec_field.serializer.as_ref().unwrap_or_else(|| {
                panic!("Serializer was not provided for test field: {test_vec_field:?}")
            }),
            Some(test_vec_field.deserializer.as_ref().unwrap_or_else(|| {
                panic!("Deserializer was not provided for test field: {test_vec_field:?}")
            })),
            test_vec_field.offload,
        )
        .expect("Error processing observed test vector value")
        .expect("Unexpected error processing observed test vector const: no value was loaded");
    }

    #[inline(always)]
    #[track_caller]
    /// Record an output and, in `Check` mode, verify it equals the stored value.
    fn check_value<O>(test_vec_field: &TestValue<O>, observed_value: &O) {
        let caller_location = Location::caller();
        let caller_location = Some(format!(
            "{}:{}",
            pretty_location_file(caller_location.file()),
            caller_location.line()
        ));
        crate::process_next_entry(
            crate::TestVectorEntryType::Output,
            test_vec_field.description.clone(),
            test_vec_field.name.clone(),
            observed_value,
            caller_location,
            Some(test_vec_field.test_value_field_code_location.clone()),
            test_vec_field.serializer.as_ref().unwrap_or_else(|| {
                panic!("Serializer was not provided for test field: {test_vec_field:?}")
            }),
            None,
            test_vec_field.offload,
        )
        .expect("Error checking observed test vector value");
    }

    /// Returns `true` when the implementation actively records/checks vectors.
    fn is_test_vector_enabled() -> bool {
        true
    }
}

#[derive(Clone, Debug)]
/// Active test‑vector implementation: records, injects, and checks entries.
pub struct TestVectorActive;

impl TestVector for TestVectorActive {}

#[derive(Clone, Debug)]
/// No‑op test‑vector implementation for production or non‑testing code paths.
///
/// All `expose_*` calls pass through values unchanged, and `check_value` is a no‑op.
pub struct TestVectorNOP;

impl TestVector for TestVectorNOP {
    #[inline(always)]
    fn initialize_test_vector<T: Into<PathBuf>>(
        _tv_file_path: T,
        _file_format: TestVectorFileFormat,
        _test_mode: TestMode,
    ) -> TlsEnvGuard {
        panic!(
            "TestVectorNOP is used (by default) for when the code runs in production.\
             No test vector was explicitly defined."
        )
    }

    #[inline(always)]
    fn expose_value<O>(_test_vec_field: &TestValue<O>, observed_value: O) -> O {
        observed_value // return the value given
    }

    #[inline(always)]
    fn expose_mut_value<O>(_test_vec_field: &TestValue<O>, _observed_mut_value: &mut O) {
        // no impl does nothing
    }

    #[inline(always)]
    fn check_value<O>(_test_vec_field: &TestValue<O>, _observed_value: &O) {
        // no impl does nothing
    }

    #[inline(always)]
    fn is_test_vector_enabled() -> bool {
        false
    }
}

#[cfg(test)]
mod tests {
    use crate::{initialize_tv_case_from_file, TestMode, TestVectorFileFormat};

    #[test]
    fn it_works() {
        let _guard: crate::TlsEnvGuard =
            initialize_tv_case_from_file("a", TestVectorFileFormat::Json, TestMode::Init).unwrap();
    }
}
